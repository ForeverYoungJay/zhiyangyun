# 智慧养老院一体化运营管理平台 — 技术设计文档

> **版本**: v1.0
> **技术栈**: Next.js 15 (管理端 Web) + 微信小程序 (家属端) + FastAPI + PostgreSQL
> **日期**: 2026-02-10

---

## 目录

1. [项目概述](#1-项目概述)
2. [系统架构总览](#2-系统架构总览)
3. [技术栈选型](#3-技术栈选型)
4. [角色与双端体系](#4-角色与双端体系)
5. [数据库设计](#5-数据库设计)
6. [七大核心业务模块](#6-七大核心业务模块)
7. [API 设计规范](#7-api-设计规范)
8. [管理端 Web 架构 (Next.js)](#8-管理端-web-架构)
9. [家属端微信小程序架构](#9-家属端微信小程序架构)
10. [后端架构 (FastAPI)](#10-后端架构)
11. [权限隔离体系](#11-权限隔离体系)
12. [审计合规体系](#12-审计合规体系)
13. [事务一致性保障](#13-事务一致性保障)
14. [幂等补偿机制](#14-幂等补偿机制)
15. [可观测与运维体系](#15-可观测与运维体系)
16. [部署与安全](#16-部署与安全)
---

## 1. 项目概述

### 1.1 项目背景

为养老院构建一体化数字运营平台，覆盖从长者入院到退院的全生命周期管理，实现 **业财一体化**（业务动作直接触发财务数据变化）。

### 1.2 交付物

| 交付物 | 技术方案 | 面向用户 |
|--------|---------|---------|
| **管理端 Web** | Next.js 15 (App Router) | 行政人员、医护人员、护理员 |
| **家属端微信小程序** | 微信原生小程序 (Skyline) | 长者家属 |
| **后端 API** | FastAPI + PostgreSQL | 统一服务两端 |

### 1.3 业务规模

| 用户类型 | 数量 | 使用端 |
|---------|------|--------|
| 行政人员 | 12 人 | 管理端 Web |
| 医护人员 | 5 人 | 管理端 Web |
| 护理员/生活管家 | 80 人 | 管理端 Web (含移动适配) |
| 在住长者 | 560 人 | — |
| 长者家属 | ~500 人 | 微信小程序 |

### 1.4 核心架构理念

- **一个中心**: 数据中心与智能决策中心
- **两端分离**: 管理端 Web (内部员工) + 家属端小程序 (外部用户)
- **七大管理**: 长者全周期、服务与护理标准化、生活与健康、人力资源与绩效、资产与房间、财务一体化、问卷与持续改进
- **三大引擎**: 工作流引擎、报表引擎、权限管理引擎

---

## 2. 系统架构总览

### 2.1 整体分层架构

```
┌──────────────────────────────────────────────────────────────┐
│                       客户端层 (Client)                       │
│                                                              │
│   ┌─────────────────────────┐    ┌────────────────────────┐  │
│   │     管理端 Web (Next.js) │    │  家属端 微信小程序       │  │
│   │                         │    │                        │  │
│   │  ┌───────┐ ┌─────────┐ │    │  ┌──────┐ ┌─────────┐ │  │
│   │  │行政模块│ │医护模块  │ │    │  │长者动态│ │费用管理  │ │  │
│   │  ├───────┤ ├─────────┤ │    │  ├──────┤ ├─────────┤ │  │
│   │  │护工模块│ │院长仪表盘│ │    │  │健康数据│ │服务增购  │ │  │
│   │  └───────┘ └─────────┘ │    │  ├──────┤ ├─────────┤ │  │
│   │                         │    │  │满意度  │ │即时沟通  │ │  │
│   │  PC 浏览器 + 移动端适配  │    │  └──────┘ └─────────┘ │  │
│   └─────────────────────────┘    └────────────────────────┘  │
│              │                              │                │
├──────────────┼──────────────────────────────┼────────────────┤
│              ▼         网关层 (Gateway)      ▼                │
│   ┌──────────────────────────────────────────────────────┐   │
│   │    Nginx (SSL终止, 限流, 负载均衡, /api → FastAPI)    │   │
│   └──────────────────────────────────────────────────────┘   │
├──────────────────────────────────────────────────────────────┤
│                      服务层 (Backend)                         │
│   ┌──────────────────────────────────────────────────────┐   │
│   │               FastAPI Application                     │   │
│   │  ┌───────────┐ ┌───────────┐ ┌───────────────────┐  │   │
│   │  │ Auth/RBAC │ │ Workflow  │ │ Business Modules  │  │   │
│   │  │  Engine   │ │  Engine   │ │  (7 Modules)      │  │   │
│   │  └───────────┘ └───────────┘ └───────────────────┘  │   │
│   │  ┌───────────┐ ┌───────────┐ ┌───────────────────┐  │   │
│   │  │  Report   │ │  Audit    │ │ Notification      │  │   │
│   │  │  Engine   │ │  Logger   │ │ (WS+微信订阅消息)  │  │   │
│   │  └───────────┘ └───────────┘ └───────────────────┘  │   │
│   └──────────────────────────────────────────────────────┘   │
├──────────────────────────────────────────────────────────────┤
│                       数据层 (Data)                           │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────┐  │
│   │PostgreSQL│ │  Redis   │ │  MinIO   │ │ Elasticsearch│  │
│   │ (主库)   │ │ (缓存)   │ │ (文件)   │ │  (日志/搜索)  │  │
│   └──────────┘ └──────────┘ └──────────┘ └──────────────┘  │
├──────────────────────────────────────────────────────────────┤
│                     基础设施层 (Infra)                        │
│   ┌──────────┐ ┌──────────────┐ ┌────────────────────────┐  │
│   │ Docker   │ │ Prometheus   │ │  Grafana / Loki        │  │
│   │ Compose  │ │ + Alertmgr   │ │  (可视化/日志聚合)      │  │
│   └──────────┘ └──────────────┘ └────────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

### 2.2 请求流转链路

```
管理端 Web (Next.js SSR/CSR)  ──┐
                                ├─→ Nginx(TLS/限流) → FastAPI(鉴权中间件)
家属端 小程序 (wx.request)     ──┘       → RBAC权限校验 → 业务Handler
                                         → Service层(事务边界)
                                         → Repository层(SQLAlchemy ORM) → PostgreSQL
                                         → 审计日志异步写入 → 返回响应

小程序特殊链路:
  微信登录 → wx.login(code) → FastAPI /auth/wx-login → 微信服务器换 openid
          → 本地 JWT 签发 → 后续请求携带 Bearer Token (与Web端一致)

消息推送链路:
  管理端 Web: WebSocket (Socket.io) 实时推送
  家属小程序: 微信订阅消息 (wx.requestSubscribeMessage) 模板推送
```

---

## 3. 技术栈选型

### 3.1 管理端 Web

| 技术 | 版本 | 用途 | 许可证 |
|-----|------|------|-------|
| Next.js | 15.x | SSR/SSG 框架，App Router | MIT |
| React | 19.x | UI 库 | MIT |
| Tailwind CSS | v4 | 原子化 CSS | MIT |
| shadcn/ui | latest | 组件库 | MIT |
| Zustand | 5.x | 轻量状态管理 | MIT |
| TanStack Query | 5.x | 服务端状态管理/缓存 | MIT |
| Socket.io-client | 4.x | WebSocket 实时通信 | MIT |
| ECharts | 5.x | 数据可视化图表 | Apache 2.0 |
| react-hook-form + zod | latest | 表单校验 | MIT |

### 3.2 家属端微信小程序

| 技术 | 版本 | 用途 | 许可证 |
|-----|------|------|-------|
| 微信小程序原生框架 | Skyline 渲染 | 小程序运行时 | 微信平台 |
| TypeScript | 5.x | 类型安全 | Apache 2.0 |
| Vant Weapp | 1.x | 小程序 UI 组件库 | MIT |
| mobx-miniprogram | 4.x | 状态管理 | MIT |
| wxs | — | 视图层脚本(高性能过滤/格式化) | 微信平台 |
| weixin-js-sdk | — | 微信支付/分享/订阅消息 | 微信平台 |

### 3.3 后端

| 技术 | 版本 | 用途 | 许可证 |
|-----|------|------|-------|
| FastAPI | 0.115+ | Web 框架 | MIT |
| SQLAlchemy | 2.x | ORM (async) | MIT |
| Alembic | 1.x | 数据库迁移 | MIT |
| Pydantic | 2.x | 数据校验/序列化 | MIT |
| Celery | 5.x | 异步任务队列 | BSD |
| Redis | 7.x | 缓存/消息代理/分布式锁 | BSD |
| PostgreSQL | 16 | 主数据库 | PostgreSQL License |
| MinIO | latest | 对象存储(文件/图片) | AGPL→客户端Apache 2.0 |
| Elasticsearch | 8.x | 全文搜索/日志 | SSPL (服务端自用合规) |

### 3.4 基础设施

| 技术 | 用途 | 许可证 |
|-----|------|-------|
| Docker + Compose | 容器化部署 | Apache 2.0 |
| Nginx | 反向代理/负载均衡 | BSD |
| Prometheus | 指标采集 | Apache 2.0 |
| Grafana | 监控仪表盘 | AGPL (自用合规) |
| Loki | 日志聚合 | AGPL (自用合规) |
| Jaeger | 分布式链路追踪 | Apache 2.0 |

---

## 4. 角色与双端体系

### 4.1 角色定义

```python
# app/models/enums.py
from enum import Enum

class UserRole(str, Enum):
    """所有角色 — 管理端 Web 和家属端小程序共用后端"""

    # ===== 管理端 Web 角色 =====
    # 行政管理
    SUPER_ADMIN = "super_admin"       # 超级管理员
    DIRECTOR = "director"             # 院长
    OPS_MANAGER = "ops_manager"       # 运营主管
    HR_MANAGER = "hr_manager"         # 人事主管
    FINANCE_MANAGER = "finance_mgr"   # 财务主管
    LOGISTICS = "logistics"           # 后勤
    ADMIN_STAFF = "admin_staff"       # 行政人员

    # 医护
    DOCTOR = "doctor"                 # 医生
    NURSE = "nurse"                   # 护士
    ASSESSOR = "assessor"             # 评估师

    # 护工
    CAREGIVER = "caregiver"           # 护理员
    LIFE_STEWARD = "life_steward"     # 生活管家

    # ===== 家属端小程序角色 =====
    FAMILY_MEMBER = "family_member"   # 长者家属

class ClientType(str, Enum):
    """客户端类型 — 区分请求来源"""
    WEB_ADMIN = "web_admin"           # 管理端 Web
    MINI_PROGRAM = "mini_program"     # 家属端微信小程序
```

### 4.2 双端-角色-功能映射

| 客户端 | 角色 | 核心功能 |
|--------|------|---------|
| **管理端 Web** | 院长 | 仪表盘(入住率/营收/护理质量/满意度/库存预警)、全模块管理、AI 决策辅助 |
| **管理端 Web** | 运营/人事/财务/后勤/行政 | 对应模块管理、审批流程、数据报表 |
| **管理端 Web** | 医生/护士/评估师 | 入院评估(GB/T 42195-2022)、健康档案、医嘱管理、用药记录 |
| **管理端 Web** | 护理员/生活管家 | 扫码执行任务、服务记录、排班查看、今日任务、绩效查看 |
| **家属小程序** | 家属 | 长者动态(照片)、健康数据、费用充值/明细、服务增购、满意度评价、即时沟通 |

### 4.3 管理端 Web 路由结构 (Next.js)

```
web-admin/app/
├── (auth)/                       # 公开路由组
│   ├── login/page.tsx            # 账号密码登录
│   └── forgot-password/page.tsx
├── (dashboard)/                  # 需鉴权路由组
│   ├── layout.tsx                # 统一侧边栏 + 头部 (按角色动态渲染菜单)
│   ├── page.tsx                  # 首页仪表盘 (角色自适应)
│   │
│   ├── elders/                   # 长者全周期管理
│   │   ├── page.tsx              # 长者列表
│   │   ├── [id]/page.tsx         # 长者详情/档案
│   │   ├── create/page.tsx       # 新增长者
│   │   └── [id]/admission/       # 入院办理
│   │
│   ├── care/                     # 护理与服务
│   │   ├── tasks/page.tsx        # 护理任务列表/看板
│   │   ├── tasks/[id]/page.tsx   # 任务详情/扫码执行
│   │   ├── packages/page.tsx     # 服务套餐管理
│   │   └── items/page.tsx        # 服务项目库
│   │
│   ├── medical/                  # 医护管理
│   │   ├── assessments/          # 入院评估
│   │   ├── records/              # 健康档案
│   │   └── prescriptions/        # 医嘱/用药
│   │
│   ├── health/                   # 生活与健康
│   │   ├── meals/                # 膳食管理
│   │   ├── activities/           # 活动管理
│   │   └── incidents/            # 安全/事故
│   │
│   ├── rooms/                    # 资产与房间
│   │   ├── buildings/            # 楼栋管理
│   │   ├── rooms/                # 房间/床位
│   │   └── qrcodes/              # 二维码管理
│   │
│   ├── hr/                       # 人力资源与绩效
│   │   ├── staff/                # 员工档案
│   │   ├── schedules/            # 排班管理
│   │   ├── attendance/           # 考勤
│   │   └── performance/          # 绩效考评
│   │
│   ├── finance/                  # 财务一体化
│   │   ├── accounts/             # 长者账户
│   │   ├── transactions/         # 交易流水
│   │   ├── billing/              # 账单管理
│   │   └── reports/              # 财务报表
│   │
│   ├── workflows/                # 流程审批
│   │   ├── page.tsx              # 审批列表(我的待办/已办)
│   │   └── [id]/page.tsx         # 审批详情
│   │
│   ├── surveys/                  # 问卷管理
│   ├── documents/                # 文档管理
│   ├── messages/                 # 即时通讯
│   └── settings/                 # 系统设置
│       ├── users/                # 用户管理
│       ├── roles/                # 角色权限
│       └── system/               # 系统参数
```

### 4.4 家属端小程序页面结构

```
mini-program/
├── app.json                      # 小程序全局配置
├── app.ts                        # 全局逻辑(登录态/token管理)
├── pages/
│   ├── login/                    # 微信授权登录 + 手机号绑定
│   ├── index/                    # 首页(长者概况卡片 + 快捷入口)
│   │
│   ├── elder/                    # 长者动态
│   │   ├── profile/              # 长者档案
│   │   ├── activities/           # 活动照片/视频
│   │   └── daily-report/         # 每日护理报告
│   │
│   ├── health/                   # 健康数据
│   │   ├── overview/             # 健康总览
│   │   ├── medical-records/      # 就医记录
│   │   └── medications/          # 用药记录
│   │
│   ├── billing/                  # 费用管理
│   │   ├── account/              # 账户余额
│   │   ├── transactions/         # 消费明细
│   │   └── topup/                # 微信支付充值
│   │
│   ├── services/                 # 服务增购
│   │   ├── catalog/              # 服务/套餐列表
│   │   └── orders/               # 我的订购
│   │
│   ├── feedback/                 # 满意度评价
│   │   ├── surveys/              # 问卷列表
│   │   └── submit/               # 填写评价
│   │
│   └── chat/                     # 即时沟通
│       └── conversation/         # 与护工/管理员对话
│
├── components/                   # 通用组件
│   ├── elder-card/               # 长者信息卡
│   ├── balance-card/             # 余额卡片
│   ├── timeline/                 # 时间线
│   └── empty-state/              # 空状态
│
├── utils/
│   ├── request.ts                # wx.request 封装(token注入/刷新/重试)
│   ├── auth.ts                   # 登录态管理
│   └── subscribe.ts              # 订阅消息管理
│
└── store/
    ├── user.ts                   # 用户/家属信息
    └── elder.ts                  # 关联长者数据
```

---

## 5. 数据库设计

### 5.1 核心实体关系 (ER 概览)

```
┌──────────┐    1:N    ┌───────────┐    N:1    ┌──────────┐
│  User    │──────────│  Elder    │──────────│  Room    │
│ (所有角色)│          │ (长者档案) │          │ (房间/床位)│
└──────────┘          └───────────┘          └──────────┘
     │                    │  │                    │
     │1:N                 │  │1:N                 │1:N
     ▼                    │  ▼                    ▼
┌──────────┐             │ ┌───────────┐    ┌──────────┐
│AuditLog  │             │ │CareRecord │    │  Bed     │
│ (审计日志)│             │ │ (护理记录) │    │ (床位)   │
└──────────┘             │ └───────────┘    └──────────┘
                         │1:N
                         ▼
                   ┌───────────┐    1:1    ┌──────────────┐
                   │  Account  │──────────│  Transaction │
                   │ (虚拟账户) │          │  (交易流水)   │
                   └───────────┘          └──────────────┘
```

### 5.2 核心表结构

```sql
-- ===== 用户与权限 =====

CREATE TABLE users (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username        VARCHAR(50) UNIQUE NOT NULL,
    password_hash   VARCHAR(255) NOT NULL,
    real_name       VARCHAR(50) NOT NULL,
    phone           VARCHAR(20) UNIQUE,
    email           VARCHAR(100),
    role            VARCHAR(30) NOT NULL,          -- UserRole 枚举
    client_type     VARCHAR(20) NOT NULL,          -- web_admin / mini_program
    openid          VARCHAR(64),                   -- 微信小程序 openid (仅家属)
    department      VARCHAR(50),
    avatar_url      VARCHAR(500),
    is_active       BOOLEAN DEFAULT TRUE,
    last_login_at   TIMESTAMPTZ,
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE permissions (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role        VARCHAR(30) NOT NULL,
    resource    VARCHAR(100) NOT NULL,             -- 如 "elder", "finance.report"
    action      VARCHAR(20) NOT NULL,              -- create/read/update/delete/export
    scope       VARCHAR(20) DEFAULT 'own',         -- own/department/all
    conditions  JSONB,                             -- 行级过滤条件
    UNIQUE(role, resource, action)
);

CREATE TABLE role_data_scopes (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role        VARCHAR(30) NOT NULL,
    entity      VARCHAR(50) NOT NULL,              -- 实体表名
    filter_col  VARCHAR(50) NOT NULL,              -- 过滤列
    filter_type VARCHAR(20) NOT NULL,              -- eq/in/dept/self
    filter_val  VARCHAR(200),                      -- 静态值(可选)
    UNIQUE(role, entity, filter_col)
);

-- ===== 长者管理 =====

CREATE TABLE elders (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    elder_no        VARCHAR(20) UNIQUE NOT NULL,   -- 长者编号
    name            VARCHAR(50) NOT NULL,
    gender          VARCHAR(10),
    birth_date      DATE,
    id_card         VARCHAR(18),                   -- 身份证(加密存储)
    photo_url       VARCHAR(500),
    qr_code         VARCHAR(200),                  -- 长者专属二维码
    health_status   VARCHAR(20),
    care_level      VARCHAR(20),                   -- 护理等级
    admission_date  DATE,
    discharge_date  DATE,
    status          VARCHAR(20) DEFAULT 'prospect', -- prospect/assessed/admitted/discharged
    building_id     UUID REFERENCES buildings(id),
    room_id         UUID REFERENCES rooms(id),
    bed_id          UUID REFERENCES beds(id),
    primary_nurse_id UUID REFERENCES users(id),    -- 责任护工
    contract_id     UUID REFERENCES contracts(id),
    assessment_report JSONB,                       -- GB/T 42195-2022 评估
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW(),
    created_by      UUID REFERENCES users(id)
);

CREATE TABLE elder_family_relations (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    elder_id    UUID NOT NULL REFERENCES elders(id),
    user_id     UUID NOT NULL REFERENCES users(id),  -- 家属 user
    relation    VARCHAR(20) NOT NULL,                 -- 子女/配偶/其他
    is_primary  BOOLEAN DEFAULT FALSE,                -- 主要联系人
    UNIQUE(elder_id, user_id)
);

-- ===== 房间与床位 =====

CREATE TABLE buildings (
    id      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name    VARCHAR(50) NOT NULL,
    floors  INT NOT NULL
);

CREATE TABLE rooms (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    building_id UUID NOT NULL REFERENCES buildings(id),
    floor       INT NOT NULL,
    room_no     VARCHAR(20) NOT NULL,
    room_type   VARCHAR(20),                      -- 单人/双人/多人
    capacity    INT NOT NULL,
    qr_code     VARCHAR(200),
    UNIQUE(building_id, room_no)
);

CREATE TABLE beds (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id     UUID NOT NULL REFERENCES rooms(id),
    bed_no      VARCHAR(10) NOT NULL,
    status      VARCHAR(20) DEFAULT 'vacant',     -- vacant/reserved/occupied/maintenance
    elder_id    UUID REFERENCES elders(id),
    UNIQUE(room_id, bed_no)
);

-- ===== 服务与护理 =====

CREATE TABLE service_items (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name        VARCHAR(100) NOT NULL,
    category    VARCHAR(30),                       -- 基础护理/康复理疗/生活服务
    unit_price  DECIMAL(10,2),
    duration_min INT,                              -- 标准服务时长(分钟)
    description TEXT,
    is_active   BOOLEAN DEFAULT TRUE
);

CREATE TABLE care_packages (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name        VARCHAR(100) NOT NULL,
    description TEXT,
    price       DECIMAL(10,2),
    period      VARCHAR(20),                       -- daily/weekly/monthly
    is_active   BOOLEAN DEFAULT TRUE
);

CREATE TABLE care_package_items (
    package_id  UUID REFERENCES care_packages(id),
    item_id     UUID REFERENCES service_items(id),
    quantity    INT DEFAULT 1,
    PRIMARY KEY (package_id, item_id)
);

CREATE TABLE elder_subscriptions (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    elder_id    UUID NOT NULL REFERENCES elders(id),
    package_id  UUID NOT NULL REFERENCES care_packages(id),
    start_date  DATE NOT NULL,
    end_date    DATE,
    status      VARCHAR(20) DEFAULT 'active',      -- active/paused/expired
    ordered_by  VARCHAR(20),                        -- system/family
    created_at  TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE care_tasks (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    elder_id        UUID NOT NULL REFERENCES elders(id),
    item_id         UUID REFERENCES service_items(id),
    subscription_id UUID REFERENCES elder_subscriptions(id),
    assigned_to     UUID NOT NULL REFERENCES users(id),    -- 护工
    scheduled_at    TIMESTAMPTZ NOT NULL,
    started_at      TIMESTAMPTZ,
    completed_at    TIMESTAMPTZ,
    status          VARCHAR(20) DEFAULT 'pending',  -- pending/in_progress/completed/cancelled
    qr_scan_in      VARCHAR(200),                   -- 扫码签入记录
    qr_scan_out     VARCHAR(200),                   -- 扫码签出记录
    notes           TEXT,
    score           INT,                             -- 服务评分(1-5)
    idempotency_key VARCHAR(64) UNIQUE,              -- 幂等键
    created_at      TIMESTAMPTZ DEFAULT NOW()
);

-- ===== 财务 =====

CREATE TABLE elder_accounts (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    elder_id    UUID UNIQUE NOT NULL REFERENCES elders(id),
    balance     DECIMAL(12,2) DEFAULT 0,            -- 积分/余额
    deposit     DECIMAL(12,2) DEFAULT 0,            -- 押金
    alert_threshold DECIMAL(10,2) DEFAULT 5000,     -- 预警阈值
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    updated_at  TIMESTAMPTZ DEFAULT NOW(),
    version     INT DEFAULT 0                        -- 乐观锁版本号
);

CREATE TABLE transactions (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    account_id      UUID NOT NULL REFERENCES elder_accounts(id),
    elder_id        UUID NOT NULL REFERENCES elders(id),
    type            VARCHAR(20) NOT NULL,            -- deposit/withdraw/charge/refund
    category        VARCHAR(30),                     -- service/care/meal/medicine/room_fee
    amount          DECIMAL(12,2) NOT NULL,
    balance_before  DECIMAL(12,2) NOT NULL,
    balance_after   DECIMAL(12,2) NOT NULL,
    reference_id    UUID,                            -- 关联业务ID
    reference_type  VARCHAR(30),                     -- care_task/meal_order/prescription
    description     VARCHAR(200),
    idempotency_key VARCHAR(64) UNIQUE NOT NULL,     -- 幂等键(必填)
    status          VARCHAR(20) DEFAULT 'completed', -- pending/completed/reversed
    reversed_by     UUID REFERENCES transactions(id),-- 冲正关联
    operator_id     UUID REFERENCES users(id),
    created_at      TIMESTAMPTZ DEFAULT NOW()
);

-- ===== 审计日志 =====

CREATE TABLE audit_logs (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id         UUID,
    user_role       VARCHAR(30),
    action          VARCHAR(20) NOT NULL,            -- CREATE/READ/UPDATE/DELETE/EXPORT/LOGIN
    resource        VARCHAR(100) NOT NULL,           -- 资源类型
    resource_id     VARCHAR(100),                    -- 资源ID
    client_type     VARCHAR(20),                    -- web_admin / mini_program
    ip_address      VARCHAR(45),
    user_agent      VARCHAR(500),
    request_method  VARCHAR(10),
    request_path    VARCHAR(500),
    request_body    JSONB,                           -- 脱敏后的请求体
    old_value       JSONB,                           -- 变更前(仅UPDATE/DELETE)
    new_value       JSONB,                           -- 变更后(仅CREATE/UPDATE)
    status_code     INT,
    error_message   TEXT,
    duration_ms     INT,
    trace_id        VARCHAR(64),                     -- 链路追踪ID
    created_at      TIMESTAMPTZ DEFAULT NOW()
);

-- 审计日志按月分区(高写入量)
-- CREATE TABLE audit_logs_2026_01 PARTITION OF audit_logs
--     FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

-- ===== 工作流 =====

CREATE TABLE workflow_definitions (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name        VARCHAR(100) NOT NULL,
    type        VARCHAR(30),                        -- leave/expense/purchase/custom
    definition  JSONB NOT NULL,                     -- 流程定义(节点/分支/会签)
    is_active   BOOLEAN DEFAULT TRUE,
    version     INT DEFAULT 1,
    created_at  TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE workflow_instances (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    definition_id   UUID NOT NULL REFERENCES workflow_definitions(id),
    initiator_id    UUID NOT NULL REFERENCES users(id),
    title           VARCHAR(200),
    form_data       JSONB NOT NULL,
    current_node    VARCHAR(50),
    status          VARCHAR(20) DEFAULT 'pending',  -- pending/approved/rejected/cancelled
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE workflow_steps (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instance_id     UUID NOT NULL REFERENCES workflow_instances(id),
    node_id         VARCHAR(50) NOT NULL,
    approver_id     UUID REFERENCES users(id),
    action          VARCHAR(20),                    -- approve/reject/delegate
    comment         TEXT,
    acted_at        TIMESTAMPTZ,
    created_at      TIMESTAMPTZ DEFAULT NOW()
);

-- ===== 索引 =====

CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource, resource_id);
CREATE INDEX idx_audit_logs_trace_id ON audit_logs(trace_id);
CREATE INDEX idx_transactions_elder_id ON transactions(elder_id);
CREATE INDEX idx_transactions_created_at ON transactions(created_at);
CREATE INDEX idx_transactions_idempotency ON transactions(idempotency_key);
CREATE INDEX idx_care_tasks_assigned ON care_tasks(assigned_to, status, scheduled_at);
CREATE INDEX idx_care_tasks_elder ON care_tasks(elder_id, scheduled_at);
CREATE INDEX idx_elders_status ON elders(status);
CREATE INDEX idx_beds_status ON beds(status);
```

### 5.3 敏感数据加密

```python
# app/core/encryption.py
from cryptography.fernet import Fernet
import os

# 身份证、手机号等 PII 字段使用 AES 对称加密
ENCRYPTION_KEY = os.getenv("FIELD_ENCRYPTION_KEY")
cipher = Fernet(ENCRYPTION_KEY)

def encrypt_field(value: str) -> str:
    return cipher.encrypt(value.encode()).decode()

def decrypt_field(encrypted: str) -> str:
    return cipher.decrypt(encrypted.encode()).decode()
```

对应 SQLAlchemy 自定义类型：

```python
# app/models/types.py
from sqlalchemy import TypeDecorator, String

class EncryptedString(TypeDecorator):
    impl = String
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is not None:
            return encrypt_field(value)
        return value

    def process_result_value(self, value, dialect):
        if value is not None:
            return decrypt_field(value)
        return value
```

---

## 6. 七大核心业务模块

### 6.1 长者全周期管理

**生命周期状态机**:

```
prospect ──→ assessed ──→ admitted ──→ discharged
  (潜客)       (已评估)     (在院)       (退院)
    │                        │  ▲
    │                        ▼  │
    │                    transferred (床位变更)
    ▼
  lost (流失)
```

**关键业务流程 — 入院办理**:

```python
# app/services/elder_service.py
class ElderService:
    async def admit_elder(
        self, db: AsyncSession, elder_id: UUID, admission: AdmissionRequest
    ) -> Elder:
        """
        入院办理: 评估 → 签合同 → 分配床位 → 生成档案与二维码
        整个流程在单个事务中完成，保证一致性
        """
        async with db.begin():
            # 1. 校验长者状态
            elder = await self.repo.get_by_id(db, elder_id)
            if elder.status != ElderStatus.ASSESSED:
                raise BusinessError("长者未完成评估，无法办理入院")

            # 2. 分配床位(行锁防并发)
            bed = await self.room_repo.lock_and_assign_bed(
                db, admission.bed_id, elder_id
            )

            # 3. 创建合同
            contract = await self.contract_repo.create(db, ContractCreate(
                elder_id=elder_id,
                start_date=admission.admission_date,
                monthly_fee=admission.monthly_fee,
            ))

            # 4. 创建虚拟账户
            account = await self.account_repo.create(db, ElderAccountCreate(
                elder_id=elder_id,
                deposit=admission.deposit_amount,
                balance=admission.deposit_amount,
            ))

            # 5. 更新长者状态
            elder.status = ElderStatus.ADMITTED
            elder.admission_date = admission.admission_date
            elder.bed_id = bed.id
            elder.room_id = bed.room_id
            elder.contract_id = contract.id
            elder.qr_code = generate_qr_code(elder.elder_no)

            # 6. 记录入院交易流水
            await self.transaction_service.create_transaction(
                db,
                account_id=account.id,
                type=TransactionType.DEPOSIT,
                amount=admission.deposit_amount,
                description="入院押金",
                idempotency_key=f"admission-{elder_id}-deposit",
            )

            return elder
```

### 6.2 服务与护理标准化管理

**质量闭环流程**:

```
套餐订阅 → 自动生成每日护理任务 → 推送至管理端(护工)
    → 护工扫码签入 → 执行服务 → 扫码签出
    → 系统自动记录时长 → 家属/主管可监督
    → 问卷反馈 → 关联护工绩效评分
```

**任务自动生成 (Celery 定时任务)**:

```python
# app/tasks/care_tasks.py
from celery import shared_task

@shared_task(bind=True, max_retries=3)
def generate_daily_care_tasks(self):
    """每日凌晨 2:00 根据订阅套餐自动生成护理任务"""
    today = date.today()
    with get_db_session() as db:
        active_subs = db.query(ElderSubscription).filter(
            ElderSubscription.status == "active",
            ElderSubscription.start_date <= today,
            or_(ElderSubscription.end_date.is_(None),
                ElderSubscription.end_date >= today),
        ).all()

        for sub in active_subs:
            for item in sub.package.items:
                idempotency_key = f"task-{sub.id}-{item.id}-{today}"
                # 幂等: 相同 key 不重复创建
                existing = db.query(CareTask).filter(
                    CareTask.idempotency_key == idempotency_key
                ).first()
                if existing:
                    continue

                task = CareTask(
                    elder_id=sub.elder_id,
                    item_id=item.id,
                    subscription_id=sub.id,
                    assigned_to=get_assigned_caregiver(sub.elder_id),
                    scheduled_at=get_scheduled_time(item, today),
                    idempotency_key=idempotency_key,
                )
                db.add(task)

        db.commit()
```

### 6.3 生活与健康管理

| 子模块 | 核心功能 | 关键实体 |
|--------|---------|---------|
| 膳食管理 | 科学食谱库、按日分配、个性化订餐 | `meal_plans`, `meal_orders` |
| 活动管理 | 策划文娱活动、记录参与情况、活动照片 | `activities`, `activity_participants` |
| 健康管理 | 就医记录、用药记录、连续健康档案 | `medical_records`, `medications` |
| 安全管理 | 事故登记与跟踪、风险预防 | `incidents`, `incident_followups` |

### 6.4 人力资源与绩效管理

**绩效计算模型**:

```python
# 综合绩效 = 任务完成率×40% + 满意度评分×30% + 查房积分×20% + 考勤×10%
class PerformanceCalculator:
    WEIGHTS = {
        "task_completion": 0.4,
        "satisfaction": 0.3,
        "inspection_score": 0.2,
        "attendance": 0.1,
    }

    async def calculate(self, user_id: UUID, period: str) -> PerformanceResult:
        task_rate = await self._get_task_completion_rate(user_id, period)
        satisfaction = await self._get_satisfaction_score(user_id, period)
        inspection = await self._get_inspection_score(user_id, period)
        attendance = await self._get_attendance_rate(user_id, period)

        total = (
            task_rate * self.WEIGHTS["task_completion"]
            + satisfaction * self.WEIGHTS["satisfaction"]
            + inspection * self.WEIGHTS["inspection_score"]
            + attendance * self.WEIGHTS["attendance"]
        )
        return PerformanceResult(
            user_id=user_id, period=period, score=round(total, 2),
            breakdown={
                "task_completion": task_rate,
                "satisfaction": satisfaction,
                "inspection_score": inspection,
                "attendance": attendance,
            }
        )
```

### 6.5 资产与房间管理

```
楼栋 (Building) 1:N
  └── 楼层 (Floor) 1:N
       └── 房间 (Room) 1:N
            └── 床位 (Bed) → 状态: 空闲/预定/在住/维修
```

每个房间和长者均有专属二维码，护工扫码可查看：房间信息、在住长者、今日任务清单。

### 6.6 财务一体化管理

**业财一体化自动扣费流程**:

```
护理服务完成 ──→ 触发 Transaction ──→ 自动扣减积分
膳食消费     ──→ 触发 Transaction ──→ 自动扣减积分
药品费用     ──→ 触发 Transaction ──→ 自动扣减积分

余额 < 阈值(5000) ──→ 自动通知家属 + 财务 + 售前
每月房费到期      ──→ 自动续费提醒
```

详见 [第 13 章: 事务一致性](#13-事务一致性保障) 中的扣费事务设计。

### 6.7 问卷与持续改进管理

多维度问卷 → 数据驱动改进：

| 问卷维度 | 评价主体 | 结果用途 |
|---------|---------|---------|
| 服务质量 | 家属 | 服务改进 |
| 环境满意度 | 家属/长者 | 设施维护 |
| 膳食评价 | 家属/长者 | 食谱优化 |
| 护理套餐 | 家属 | 套餐调整 |
| 护工评价 | 家属/主管 | 绩效考评、排名 |

---

## 7. API 设计规范

### 7.1 RESTful 路由规范

```
前缀: /api/v1

======= 通用认证 =======

  POST   /api/v1/auth/login                # 管理端: 账号密码登录
  POST   /api/v1/auth/wx-login             # 小程序: 微信 code 登录
  POST   /api/v1/auth/wx-bindphone         # 小程序: 绑定手机号
  POST   /api/v1/auth/refresh              # 刷新 token (双端通用)
  POST   /api/v1/auth/logout               # 登出

======= 管理端 Web 接口 =======

长者管理:
  GET    /api/v1/elders                    # 列表(分页/筛选)
  POST   /api/v1/elders                    # 创建
  GET    /api/v1/elders/{id}               # 详情
  PUT    /api/v1/elders/{id}               # 更新
  POST   /api/v1/elders/{id}/admit         # 入院办理
  POST   /api/v1/elders/{id}/discharge     # 退院结算
  GET    /api/v1/elders/{id}/care-records  # 护理记录

护理任务:
  GET    /api/v1/care-tasks                # 任务列表
  POST   /api/v1/care-tasks/{id}/scan-in   # 扫码签入
  POST   /api/v1/care-tasks/{id}/scan-out  # 扫码签出

财务:
  GET    /api/v1/accounts/{elder_id}       # 账户信息
  POST   /api/v1/accounts/{elder_id}/topup # 充值
  GET    /api/v1/transactions              # 流水查询
  GET    /api/v1/reports/finance/monthly   # 月度报表

工作流:
  POST   /api/v1/workflows                # 发起审批
  POST   /api/v1/workflows/{id}/approve   # 审批通过
  POST   /api/v1/workflows/{id}/reject    # 驳回

======= 家属小程序专用接口 (/family 前缀) =======

  GET    /api/v1/family/elders             # 我关联的长者列表
  GET    /api/v1/family/elders/{id}        # 长者详情(脱敏)
  GET    /api/v1/family/elders/{id}/daily  # 每日护理报告
  GET    /api/v1/family/elders/{id}/activities  # 活动照片

  GET    /api/v1/family/health/{elder_id}  # 健康数据总览
  GET    /api/v1/family/health/{elder_id}/records  # 就医记录
  GET    /api/v1/family/health/{elder_id}/meds     # 用药记录

  GET    /api/v1/family/billing/{elder_id}          # 账户余额
  GET    /api/v1/family/billing/{elder_id}/transactions # 消费明细
  POST   /api/v1/family/billing/{elder_id}/topup    # 微信支付充值
  POST   /api/v1/family/billing/{elder_id}/topup/callback # 微信支付回调

  GET    /api/v1/family/services/catalog   # 可增购服务列表
  POST   /api/v1/family/services/order     # 服务增购下单

  GET    /api/v1/family/surveys            # 待填问卷
  POST   /api/v1/family/surveys/{id}       # 提交评价

  GET    /api/v1/family/chat/conversations # 对话列表
  POST   /api/v1/family/chat/send          # 发送消息
```

### 7.2 统一响应格式

```python
# app/schemas/response.py
from pydantic import BaseModel
from typing import Generic, TypeVar, Optional, List

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    code: int = 0                       # 0=成功, 非0=业务错误码
    message: str = "success"
    data: Optional[T] = None
    trace_id: Optional[str] = None      # 链路追踪ID

class PageResponse(BaseModel, Generic[T]):
    code: int = 0
    message: str = "success"
    data: Optional[List[T]] = None
    total: int = 0
    page: int = 1
    page_size: int = 20
    trace_id: Optional[str] = None
```

### 7.3 请求头规范

```
Authorization: Bearer <access_token>
X-Client-Type: web_admin | mini_program            # 客户端类型
X-Idempotency-Key: <uuid>                         # 写操作幂等键
X-Request-Id: <uuid>                               # 请求追踪ID
Content-Type: application/json
```

管理端 Web 通过 Axios 拦截器自动注入 `X-Client-Type: web_admin`；
小程序通过 `request.ts` 封装自动注入 `X-Client-Type: mini_program`。

---

## 8. 管理端 Web 架构 (Next.js)

### 8.1 项目结构

```
web-admin/
├── app/                          # App Router
│   ├── (auth)/                   # 公开路由组 (登录/忘记密码)
│   ├── (dashboard)/              # 需鉴权路由组 (按角色动态菜单)
│   ├── layout.tsx                # 根 layout
│   ├── globals.css               # Tailwind v4 (@import "tailwindcss")
│   └── providers.tsx             # QueryClientProvider, AuthProvider
├── components/
│   ├── ui/                       # shadcn/ui 基础组件
│   ├── layout/                   # Sidebar, Header (角色自适应菜单)
│   ├── dashboard/                # 仪表盘组件 (ECharts)
│   ├── elder/                    # 长者管理业务组件
│   ├── care/                     # 护理任务组件(含扫码)
│   ├── medical/                  # 医护组件(评估/医嘱)
│   ├── finance/                  # 财务组件
│   └── workflow/                 # 工作流审批组件
├── lib/
│   ├── api-client.ts             # Axios 实例 + 拦截器
│   ├── auth.ts                   # Token 管理
│   ├── permissions.ts            # 前端 RBAC 权限判断
│   ├── socket.ts                 # Socket.io 客户端
│   └── utils.ts
├── hooks/
│   ├── use-auth.ts
│   ├── use-permission.ts         # 角色权限 hook
│   ├── use-menu.ts               # 按角色生成菜单
│   └── use-realtime.ts
├── stores/
│   ├── auth-store.ts             # Zustand: 用户状态
│   └── notification-store.ts
└── types/
    └── index.ts                  # 全局类型定义
```

### 8.2 角色自适应布局

```tsx
// app/(dashboard)/layout.tsx
import { redirect } from "next/navigation";
import { getServerSession } from "@/lib/auth-server";
import { Sidebar } from "@/components/layout/sidebar";
import { Header } from "@/components/layout/header";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession();
  if (!session) redirect("/login");

  // 家属角色不能登录管理端
  if (session.role === "family_member") {
    redirect("/login?error=请使用微信小程序访问");
  }

  return (
    <div className="flex h-screen">
      {/* Sidebar 根据 role 动态渲染菜单项 */}
      <Sidebar role={session.role} />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Header user={session} />
        <main className="flex-1 overflow-auto p-6">{children}</main>
      </div>
    </div>
  );
}
```

### 8.3 角色动态菜单

```tsx
// hooks/use-menu.ts
import { UserRole } from "@/types";

interface MenuItem {
  label: string;
  href: string;
  icon: string;
  roles: UserRole[];  // 哪些角色可见
}

const ALL_ADMIN: UserRole[] = ["super_admin", "director", "ops_manager",
  "hr_manager", "finance_mgr", "logistics", "admin_staff"];
const MEDICAL: UserRole[] = ["doctor", "nurse", "assessor"];
const CAREGIVER: UserRole[] = ["caregiver", "life_steward"];

export const MENU_CONFIG: MenuItem[] = [
  { label: "仪表盘", href: "/", icon: "LayoutDashboard",
    roles: [...ALL_ADMIN, ...MEDICAL, ...CAREGIVER] },

  // 行政管理模块
  { label: "长者管理", href: "/elders", icon: "Users",
    roles: ALL_ADMIN },
  { label: "房间管理", href: "/rooms", icon: "Building2",
    roles: ["super_admin", "director", "ops_manager", "logistics"] },
  { label: "财务管理", href: "/finance", icon: "Wallet",
    roles: ["super_admin", "director", "finance_mgr"] },
  { label: "人力资源", href: "/hr", icon: "UserCog",
    roles: ["super_admin", "director", "hr_manager"] },
  { label: "流程审批", href: "/workflows", icon: "GitPullRequest",
    roles: ALL_ADMIN },
  { label: "问卷管理", href: "/surveys", icon: "ClipboardList",
    roles: ["super_admin", "director", "ops_manager"] },
  { label: "文档管理", href: "/documents", icon: "FileText",
    roles: ALL_ADMIN },

  // 医护模块
  { label: "入院评估", href: "/medical/assessments", icon: "Stethoscope",
    roles: MEDICAL },
  { label: "健康档案", href: "/medical/records", icon: "HeartPulse",
    roles: [...MEDICAL, "director"] },
  { label: "医嘱管理", href: "/medical/prescriptions", icon: "Pill",
    roles: MEDICAL },

  // 护理模块
  { label: "服务套餐", href: "/care/packages", icon: "Package",
    roles: [...ALL_ADMIN, ...CAREGIVER] },
  { label: "护理任务", href: "/care/tasks", icon: "CheckSquare",
    roles: [...ALL_ADMIN, ...MEDICAL, ...CAREGIVER] },
  { label: "我的排班", href: "/hr/schedules", icon: "Calendar",
    roles: [...CAREGIVER, ...MEDICAL] },
  { label: "我的绩效", href: "/hr/performance", icon: "TrendingUp",
    roles: CAREGIVER },

  // 通用
  { label: "消息", href: "/messages", icon: "MessageSquare",
    roles: [...ALL_ADMIN, ...MEDICAL, ...CAREGIVER] },
  { label: "系统设置", href: "/settings", icon: "Settings",
    roles: ["super_admin"] },
];

export function useMenu(role: UserRole) {
  return MENU_CONFIG.filter((item) => item.roles.includes(role));
}
```

### 8.4 前端权限组件

```tsx
// components/permission-gate.tsx
"use client";

import { usePermission } from "@/hooks/use-permission";
import { ReactNode } from "react";

interface Props {
  resource: string;
  action: "create" | "read" | "update" | "delete" | "export";
  fallback?: ReactNode;
  children: ReactNode;
}

export function PermissionGate({ resource, action, fallback, children }: Props) {
  const { hasPermission } = usePermission();
  if (!hasPermission(resource, action)) {
    return fallback ?? null;
  }
  return <>{children}</>;
}

// 使用示例:
// <PermissionGate resource="finance.report" action="export">
//   <ExportButton />
// </PermissionGate>
```

### 8.5 实时通知 (WebSocket)

```tsx
// hooks/use-realtime.ts — 管理端 Web 专用
"use client";

import { useEffect } from "react";
import { io, Socket } from "socket.io-client";
import { useAuthStore } from "@/stores/auth-store";
import { useNotificationStore } from "@/stores/notification-store";

let socket: Socket | null = null;

export function useRealtime() {
  const token = useAuthStore((s) => s.accessToken);
  const addNotification = useNotificationStore((s) => s.add);

  useEffect(() => {
    if (!token) return;

    socket = io(process.env.NEXT_PUBLIC_WS_URL!, {
      auth: { token },
      transports: ["websocket"],
    });

    socket.on("notification", (data) => addNotification(data));

    socket.on("balance_alert", (data) => {
      addNotification({
        type: "warning",
        title: "余额预警",
        message: `${data.elder_name} 账户余额 ${data.balance} 元，低于阈值`,
      });
    });

    socket.on("care_task_assigned", (data) => {
      addNotification({
        type: "info",
        title: "新任务",
        message: `请为 ${data.elder_name} 执行: ${data.service_name}`,
      });
    });

    return () => { socket?.disconnect(); };
  }, [token]);
}
```

---

## 9. 家属端微信小程序架构

### 9.1 小程序与管理端 Web 的关系

```
┌─────────────────────────────────────────────────────────┐
│                    FastAPI 统一后端                       │
│                                                         │
│   /api/v1/auth/login          ← 管理端 Web (账号密码)    │
│   /api/v1/auth/wx-login       ← 小程序 (微信 code 登录)  │
│                                                         │
│   /api/v1/elders/*            ← 管理端: 全量CRUD         │
│   /api/v1/family/elders/*     ← 小程序: 只读关联长者      │
│                                                         │
│   /api/v1/accounts/*          ← 管理端: 全量管理          │
│   /api/v1/family/billing/*    ← 小程序: 查看+充值         │
│                                                         │
│   WebSocket                   ← 管理端 Web 实时推送       │
│   微信订阅消息                 ← 小程序 模板消息推送       │
└─────────────────────────────────────────────────────────┘
```

### 9.2 微信登录流程

```
家属打开小程序
  → wx.login() 获取 code
  → POST /api/v1/auth/wx-login { code }
  → FastAPI 调用微信 code2Session 接口
  → 获取 openid + session_key
  → 查找已绑定用户 or 创建新用户
  → 签发 JWT (access_token + refresh_token)
  → 返回给小程序，存入 wx.setStorageSync

首次登录需绑定:
  → wx.getPhoneNumber() 获取手机号
  → POST /api/v1/auth/wx-bindphone { encrypted_data, iv }
  → 后端解密获取手机号 → 关联家属账号
```

```python
# app/api/v1/auth.py — 微信登录端点
@router.post("/wx-login")
async def wx_login(
    body: WxLoginRequest,
    db: AsyncSession = Depends(get_db),
):
    """微信小程序登录: code → openid → JWT"""
    # 1. 调用微信 code2Session
    wx_resp = await httpx_client.get(
        "https://api.weixin.qq.com/sns/jscode2session",
        params={
            "appid": settings.WX_APP_ID,
            "secret": settings.WX_APP_SECRET,
            "js_code": body.code,
            "grant_type": "authorization_code",
        },
    )
    wx_data = wx_resp.json()
    openid = wx_data.get("openid")
    if not openid:
        raise HTTPException(401, "微信登录失败")

    # 2. 查找或创建用户
    user = await user_repo.get_by_openid(db, openid)
    if not user:
        # 新用户，需要后续绑定手机号
        user = await user_repo.create(db, UserCreate(
            openid=openid,
            role=UserRole.FAMILY_MEMBER,
            client_type=ClientType.MINI_PROGRAM,
            is_active=True,
        ))

    # 3. 签发 JWT (与管理端格式一致)
    tokens = create_token_pair(user_id=str(user.id), role=user.role,
                                client_type=ClientType.MINI_PROGRAM)
    return {"access_token": tokens.access, "refresh_token": tokens.refresh,
            "need_bindphone": user.phone is None}
```

### 9.3 小程序请求封装

```typescript
// mini-program/utils/request.ts
const BASE_URL = "https://api.example.com/api/v1";

interface RequestOptions {
  url: string;
  method?: "GET" | "POST" | "PUT" | "DELETE";
  data?: any;
  idempotencyKey?: string;  // 写操作幂等键
}

export function request<T>(options: RequestOptions): Promise<T> {
  const token = wx.getStorageSync("access_token");
  const header: Record<string, string> = {
    "Content-Type": "application/json",
    "X-Client-Type": "mini_program",
  };
  if (token) header["Authorization"] = `Bearer ${token}`;
  if (options.idempotencyKey) {
    header["X-Idempotency-Key"] = options.idempotencyKey;
  }

  return new Promise((resolve, reject) => {
    wx.request({
      url: `${BASE_URL}${options.url}`,
      method: options.method || "GET",
      data: options.data,
      header,
      success(res) {
        if (res.statusCode === 401) {
          // Token 过期，尝试刷新
          refreshTokenAndRetry(options).then(resolve).catch(reject);
          return;
        }
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve((res.data as any).data as T);
        } else {
          reject(new Error((res.data as any).message || "请求失败"));
        }
      },
      fail(err) {
        reject(err);
      },
    });
  });
}

async function refreshTokenAndRetry<T>(options: RequestOptions): Promise<T> {
  const refreshToken = wx.getStorageSync("refresh_token");
  const res = await request<{ access_token: string; refresh_token: string }>({
    url: "/auth/refresh",
    method: "POST",
    data: { refresh_token: refreshToken },
  });
  wx.setStorageSync("access_token", res.access_token);
  wx.setStorageSync("refresh_token", res.refresh_token);
  return request<T>(options);
}
```

### 9.4 微信支付充值

```python
# app/services/wx_pay_service.py
class WxPayService:
    async def create_topup_order(
        self,
        db: AsyncSession,
        elder_id: UUID,
        amount: Decimal,
        user: User,
        idempotency_key: str,
    ) -> WxPayOrderResponse:
        """创建微信支付充值订单"""
        # 1. 幂等检查
        existing = await self._check_idempotency(db, idempotency_key)
        if existing:
            return existing

        # 2. 创建待支付交易记录
        order_no = generate_order_no()  # 商户订单号
        txn = await self.txn_repo.create(db, Transaction(
            account_id=await self._get_account_id(db, elder_id),
            elder_id=elder_id,
            type="deposit",
            category="topup",
            amount=amount,
            status="pending",
            idempotency_key=idempotency_key,
            description=f"微信支付充值 {amount} 元",
        ))

        # 3. 调用微信统一下单 API
        prepay = await self._call_wx_unified_order(
            order_no=order_no,
            amount=int(amount * 100),  # 微信单位: 分
            openid=user.openid,
            description=f"养老院账户充值",
        )

        # 4. 返回小程序支付参数
        return WxPayOrderResponse(
            order_no=order_no,
            **self._sign_for_miniprogram(prepay["prepay_id"]),
        )

    async def handle_pay_callback(self, payload: dict):
        """微信支付回调 — 幂等处理"""
        order_no = payload["out_trade_no"]
        # 幂等: 检查订单是否已处理
        txn = await self.txn_repo.get_by_order_no(order_no)
        if txn.status == "completed":
            return  # 已处理，忽略重复回调

        if payload["result_code"] == "SUCCESS":
            async with db.begin():
                # 更新账户余额 + 标记交易完成
                await self.account_service.topup(
                    db, txn.elder_id, txn.amount,
                    idempotency_key=f"wx-callback-{order_no}",
                )
                txn.status = "completed"
```

### 9.5 订阅消息推送 (替代 WebSocket)

```python
# app/services/wx_subscribe_service.py
class WxSubscribeService:
    """微信订阅消息 — 家属端推送通知"""

    # 消息模板 ID (需在微信后台申请)
    TEMPLATES = {
        "balance_alert": "xxxxxxxx",       # 余额预警提醒
        "care_report": "xxxxxxxx",         # 每日护理报告
        "service_complete": "xxxxxxxx",    # 服务完成通知
        "payment_success": "xxxxxxxx",     # 充值成功通知
    }

    async def send_balance_alert(self, openid: str, elder_name: str,
                                  balance: float, threshold: float):
        """推送余额预警给家属"""
        await self._send(
            openid=openid,
            template_id=self.TEMPLATES["balance_alert"],
            data={
                "thing1": {"value": elder_name},           # 长者姓名
                "amount2": {"value": f"{balance:.2f}元"},  # 当前余额
                "thing3": {"value": f"余额低于{threshold}元，请及时充值"},
            },
            page="pages/billing/account",  # 点击跳转到充值页
        )

    async def send_daily_care_report(self, openid: str, elder_name: str,
                                      task_count: int, date_str: str):
        """推送每日护理报告"""
        await self._send(
            openid=openid,
            template_id=self.TEMPLATES["care_report"],
            data={
                "thing1": {"value": elder_name},
                "date2": {"value": date_str},
                "number3": {"value": str(task_count)},
                "thing4": {"value": "今日护理已完成，点击查看详情"},
            },
            page="pages/elder/daily-report",
        )

    async def _send(self, openid: str, template_id: str,
                     data: dict, page: str):
        """调用微信订阅消息接口"""
        access_token = await self._get_access_token()
        await httpx_client.post(
            "https://api.weixin.qq.com/cgi-bin/message/subscribe/send",
            params={"access_token": access_token},
            json={
                "touser": openid,
                "template_id": template_id,
                "page": page,
                "data": data,
                "miniprogram_state": "formal",
            },
        )
```

---

## 10. 后端架构 (FastAPI)

### 10.1 项目结构

```
backend/
├── app/
│   ├── main.py                   # FastAPI app 入口
│   ├── core/
│   │   ├── config.py             # Pydantic Settings
│   │   ├── security.py           # JWT/密码哈希
│   │   ├── encryption.py         # 字段加密
│   │   ├── database.py           # AsyncSession 工厂
│   │   └── redis.py              # Redis 连接池
│   ├── middleware/
│   │   ├── auth.py               # 认证中间件
│   │   ├── audit.py              # 审计日志中间件
│   │   ├── trace.py              # 链路追踪中间件
│   │   ├── rate_limit.py         # 限流中间件
│   │   └── idempotency.py        # 幂等中间件
│   ├── api/
│   │   └── v1/
│   │       ├── auth.py               # 双端认证(密码+微信登录)
│   │       ├── elders.py
│   │       ├── care_tasks.py
│   │       ├── accounts.py
│   │       ├── workflows.py
│   │       ├── reports.py
│   │       ├── rooms.py
│   │       ├── hr.py
│   │       ├── surveys.py
│   │       ├── documents.py
│   │       └── family/               # 家属小程序专用路由
│   │           ├── elders.py          # 关联长者只读
│   │           ├── billing.py         # 费用+微信支付
│   │           ├── health.py          # 健康数据
│   │           ├── services.py        # 服务增购
│   │           ├── surveys.py         # 满意度评价
│   │           └── chat.py            # 即时沟通
│   ├── services/                 # 业务逻辑层
│   │   ├── elder_service.py
│   │   ├── care_service.py
│   │   ├── account_service.py
│   │   ├── workflow_engine.py
│   │   ├── report_engine.py
│   │   ├── notification_service.py
│   │   ├── wx_pay_service.py     # 微信支付
│   │   └── wx_subscribe_service.py # 微信订阅消息
│   ├── repositories/             # 数据访问层
│   ├── models/                   # SQLAlchemy ORM 模型
│   ├── schemas/                  # Pydantic 请求/响应 Schema
│   ├── tasks/                    # Celery 异步任务
│   │   ├── care_tasks.py         # 每日护理任务生成
│   │   ├── billing.py            # 月度账单/自动扣费
│   │   ├── alerts.py             # 余额预警
│   │   └── reports.py            # 报表生成
│   └── websocket/                # WebSocket 事件处理
│       ├── manager.py
│       └── events.py
├── alembic/                      # 数据库迁移
├── tests/
├── celery_worker.py
├── pyproject.toml
└── Dockerfile
```

### 10.2 应用入口与中间件链

```python
# app/main.py
from fastapi import FastAPI
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 启动: 初始化连接池
    await init_db()
    await init_redis()
    yield
    # 关闭: 清理资源
    await close_db()
    await close_redis()

app = FastAPI(
    title="智慧养老院管理平台",
    version="1.0.0",
    lifespan=lifespan,
)

# 中间件注册顺序(外→内): 最先注册的最后执行
app.add_middleware(RateLimitMiddleware, rpm=60)
app.add_middleware(TraceMiddleware)           # 生成 trace_id
app.add_middleware(AuditMiddleware)           # 审计日志
app.add_middleware(AuthMiddleware)            # JWT 鉴权
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 路由注册 — 管理端 Web
app.include_router(auth_router, prefix="/api/v1/auth", tags=["认证"])
app.include_router(elder_router, prefix="/api/v1/elders", tags=["长者管理"])
app.include_router(care_router, prefix="/api/v1/care-tasks", tags=["护理任务"])
app.include_router(account_router, prefix="/api/v1/accounts", tags=["财务"])
app.include_router(workflow_router, prefix="/api/v1/workflows", tags=["工作流"])
app.include_router(room_router, prefix="/api/v1/rooms", tags=["房间管理"])
app.include_router(hr_router, prefix="/api/v1/hr", tags=["人力资源"])
app.include_router(report_router, prefix="/api/v1/reports", tags=["报表"])

# 路由注册 — 家属小程序专用
app.include_router(family_elder_router, prefix="/api/v1/family/elders", tags=["小程序-长者"])
app.include_router(family_billing_router, prefix="/api/v1/family/billing", tags=["小程序-费用"])
app.include_router(family_health_router, prefix="/api/v1/family/health", tags=["小程序-健康"])
app.include_router(family_service_router, prefix="/api/v1/family/services", tags=["小程序-服务"])
app.include_router(family_survey_router, prefix="/api/v1/family/surveys", tags=["小程序-评价"])
app.include_router(family_chat_router, prefix="/api/v1/family/chat", tags=["小程序-沟通"])
```

### 10.3 依赖注入

```python
# app/core/deps.py
from fastapi import Depends, Header
from sqlalchemy.ext.asyncio import AsyncSession

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_factory() as session:
        yield session

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db),
) -> User:
    payload = decode_jwt(token)
    user = await user_repo.get_by_id(db, payload["sub"])
    if not user or not user.is_active:
        raise HTTPException(401, "用户不存在或已禁用")
    return user

async def get_client_type(
    x_client_type: str = Header(default="web_admin"),
) -> ClientType:
    """从请求头获取客户端类型，用于权限隔离"""
    try:
        return ClientType(x_client_type)
    except ValueError:
        raise HTTPException(400, f"无效的客户端类型: {x_client_type}")

def require_permission(resource: str, action: str):
    """权限校验依赖工厂"""
    async def checker(
        user: User = Depends(get_current_user),
        client_type: ClientType = Depends(get_client_type),
        db: AsyncSession = Depends(get_db),
    ):
        has = await permission_service.check(db, user.role, resource, action)
        if not has:
            raise HTTPException(403, f"无权限: {resource}:{action}")
        return user
    return Depends(checker)
```

---

## 11. 权限隔离体系

### 11.1 多层权限模型

```
┌─────────────────────────────────────────────────────┐
│                   第1层: 客户端隔离                     │
│  请求头 X-Client-Type 区分管理端Web / 家属小程序        │
│  不同客户端只能访问对应前缀的路由和数据                  │
├─────────────────────────────────────────────────────┤
│                   第2层: RBAC 功能权限                  │
│  role + resource + action → 是否允许操作               │
│  如: finance_mgr + finance.report + export → ✓       │
├─────────────────────────────────────────────────────┤
│                   第3层: 数据行级权限                    │
│  role + entity + filter → 只能看到自己负责的数据         │
│  如: caregiver 只能查看分配给自己的 care_tasks          │
├─────────────────────────────────────────────────────┤
│                   第4层: 字段级权限                      │
│  敏感字段(身份证/手机)按角色脱敏                        │
│  如: family_member 看不到长者身份证号                    │
└─────────────────────────────────────────────────────┘
```

### 11.2 客户端隔离 (第1层)

```python
# app/middleware/auth.py

# 管理端 Web: 内部员工访问主接口
WEB_ADMIN_ROUTES = [
    "/api/v1/elders", "/api/v1/care-tasks", "/api/v1/accounts",
    "/api/v1/hr", "/api/v1/rooms", "/api/v1/workflows",
    "/api/v1/reports", "/api/v1/surveys", "/api/v1/documents",
    "/api/v1/medical", "/api/v1/messages",
]
WEB_ADMIN_ROLES = [
    UserRole.SUPER_ADMIN, UserRole.DIRECTOR, UserRole.OPS_MANAGER,
    UserRole.HR_MANAGER, UserRole.FINANCE_MANAGER, UserRole.LOGISTICS,
    UserRole.ADMIN_STAFF, UserRole.DOCTOR, UserRole.NURSE,
    UserRole.ASSESSOR, UserRole.CAREGIVER, UserRole.LIFE_STEWARD,
]

# 家属小程序: 只能访问 /api/v1/family/* 前缀的接口
MINI_PROGRAM_ROUTES = ["/api/v1/family/"]
MINI_PROGRAM_ROLES = [UserRole.FAMILY_MEMBER]

CLIENT_ROUTE_MAP = {
    ClientType.WEB_ADMIN: (WEB_ADMIN_ROUTES, WEB_ADMIN_ROLES),
    ClientType.MINI_PROGRAM: (MINI_PROGRAM_ROUTES, MINI_PROGRAM_ROLES),
}

class AuthMiddleware:
    async def __call__(self, request: Request, call_next):
        # ... JWT 验证后 ...
        client_type = request.headers.get("X-Client-Type", "web_admin")
        user_role = request.state.user.role

        routes, roles = CLIENT_ROUTE_MAP.get(client_type, ([], []))

        # 客户端-角色校验
        if user_role not in roles:
            return JSONResponse(403, {"message": "角色无权访问此客户端"})

        # 客户端-路由校验
        path = request.url.path
        if not any(path.startswith(p) for p in routes):
            return JSONResponse(403, {"message": "此客户端无权访问该接口"})

        return await call_next(request)
```

### 11.3 RBAC 功能权限 (第2层)

```python
# app/services/permission_service.py
class PermissionService:
    def __init__(self):
        self._cache: dict[str, list[Permission]] = {}

    async def check(
        self, db: AsyncSession, role: str, resource: str, action: str
    ) -> bool:
        """检查角色是否拥有对资源的操作权限"""
        cache_key = f"perm:{role}"
        if cache_key not in self._cache:
            perms = await self._load_permissions(db, role)
            self._cache[cache_key] = perms
            # Redis 缓存 5 分钟
            await redis.setex(cache_key, 300, json.dumps([p.dict() for p in perms]))

        return any(
            p.resource == resource and p.action == action
            for p in self._cache[cache_key]
        )

    async def get_data_scope(
        self, db: AsyncSession, role: str, entity: str
    ) -> Optional[DataScope]:
        """获取角色对某实体的数据范围限制"""
        scope = await db.execute(
            select(RoleDataScope).where(
                RoleDataScope.role == role,
                RoleDataScope.entity == entity,
            )
        )
        return scope.scalar_one_or_none()
```

### 11.4 行级数据隔离 (第3层)

```python
# app/repositories/base.py
class BaseRepository(Generic[T]):
    def __init__(self, model: Type[T]):
        self.model = model

    async def list_with_scope(
        self,
        db: AsyncSession,
        user: User,
        filters: dict | None = None,
        page: int = 1,
        page_size: int = 20,
    ) -> tuple[list[T], int]:
        """带数据隔离的列表查询"""
        query = select(self.model)

        # 应用行级权限
        scope = await permission_service.get_data_scope(
            db, user.role, self.model.__tablename__
        )
        if scope:
            if scope.filter_type == "self":
                # 护工只看自己的任务
                query = query.where(
                    getattr(self.model, scope.filter_col) == user.id
                )
            elif scope.filter_type == "dept":
                # 部门主管看本部门数据
                query = query.where(
                    getattr(self.model, scope.filter_col) == user.department
                )
            elif scope.filter_type == "family":
                # 家属只看关联长者的数据
                elder_ids = await self._get_family_elder_ids(db, user.id)
                query = query.where(
                    getattr(self.model, scope.filter_col).in_(elder_ids)
                )
            # scope.filter_type == "all" 则不加过滤(院长/超管)

        # 应用业务过滤
        if filters:
            for k, v in filters.items():
                if hasattr(self.model, k) and v is not None:
                    query = query.where(getattr(self.model, k) == v)

        # 分页
        total = await db.scalar(select(func.count()).select_from(query.subquery()))
        items = (await db.execute(
            query.offset((page - 1) * page_size).limit(page_size)
        )).scalars().all()

        return items, total
```

### 11.5 字段级脱敏 (第4层)

```python
# app/schemas/elder.py
from pydantic import model_validator

class ElderResponse(BaseModel):
    id: UUID
    elder_no: str
    name: str
    id_card: str | None = None      # 身份证(可能脱敏)
    phone: str | None = None         # 手机(可能脱敏)
    # ... 其他字段 ...

    class Config:
        from_attributes = True

    @staticmethod
    def mask_for_role(elder: "ElderResponse", role: str) -> "ElderResponse":
        """按角色脱敏敏感字段"""
        FULL_ACCESS_ROLES = {"super_admin", "director", "finance_mgr"}
        if role not in FULL_ACCESS_ROLES:
            if elder.id_card:
                elder.id_card = elder.id_card[:6] + "********" + elder.id_card[-4:]
            if elder.phone:
                elder.phone = elder.phone[:3] + "****" + elder.phone[-4:]
        return elder
```

### 11.6 权限数据初始化

```python
# 默认权限矩阵(部分)
DEFAULT_PERMISSIONS = [
    # 院长: 全资源全操作
    {"role": "director", "resource": "*", "action": "*", "scope": "all"},

    # 财务主管: 财务模块全操作 + 长者只读
    {"role": "finance_mgr", "resource": "finance.*", "action": "*", "scope": "all"},
    {"role": "finance_mgr", "resource": "elder", "action": "read", "scope": "all"},

    # 护理员: 只能操作分配给自己的任务
    {"role": "caregiver", "resource": "care_task", "action": "read", "scope": "own"},
    {"role": "caregiver", "resource": "care_task", "action": "update", "scope": "own"},
    {"role": "caregiver", "resource": "elder", "action": "read", "scope": "own"},

    # 家属: 只读关联长者数据
    {"role": "family_member", "resource": "elder", "action": "read", "scope": "family"},
    {"role": "family_member", "resource": "account", "action": "read", "scope": "family"},
    {"role": "family_member", "resource": "service", "action": "create", "scope": "family"},
    {"role": "family_member", "resource": "feedback", "action": "create", "scope": "family"},
]
```

---

## 12. 审计合规体系

### 12.1 审计日志自动采集

```python
# app/middleware/audit.py
import time
import json
from starlette.middleware.base import BaseHTTPMiddleware

# 无需审计的路由
SKIP_PATHS = {"/api/v1/auth/refresh", "/health", "/metrics"}
# 需记录请求体的写操作
WRITE_METHODS = {"POST", "PUT", "PATCH", "DELETE"}

class AuditMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        if request.url.path in SKIP_PATHS:
            return await call_next(request)

        start = time.monotonic()
        trace_id = request.state.trace_id  # 由 TraceMiddleware 注入
        user = getattr(request.state, "user", None)

        # 读取并脱敏请求体
        request_body = None
        if request.method in WRITE_METHODS:
            body = await request.body()
            request_body = self._sanitize_body(body)

        response = await call_next(request)

        duration_ms = int((time.monotonic() - start) * 1000)

        # 异步写入审计日志(不阻塞响应)
        audit_entry = AuditLogCreate(
            user_id=user.id if user else None,
            user_role=user.role if user else None,
            action=self._method_to_action(request.method),
            resource=self._extract_resource(request.url.path),
            resource_id=self._extract_resource_id(request.url.path),
            client_type=request.headers.get("X-Client-Type"),
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent", "")[:500],
            request_method=request.method,
            request_path=str(request.url.path),
            request_body=request_body,
            status_code=response.status_code,
            duration_ms=duration_ms,
            trace_id=trace_id,
        )

        # 推入 Celery 异步任务写入
        write_audit_log.delay(audit_entry.dict())

        return response

    def _sanitize_body(self, body: bytes) -> dict | None:
        """脱敏请求体: 移除密码、token 等敏感字段"""
        try:
            data = json.loads(body)
            SENSITIVE_KEYS = {"password", "token", "id_card", "credit_card"}
            return {
                k: "***REDACTED***" if k in SENSITIVE_KEYS else v
                for k, v in data.items()
            }
        except (json.JSONDecodeError, AttributeError):
            return None

    def _method_to_action(self, method: str) -> str:
        return {"GET": "READ", "POST": "CREATE", "PUT": "UPDATE",
                "PATCH": "UPDATE", "DELETE": "DELETE"}.get(method, method)
```

### 12.2 业务变更快照 (old_value / new_value)

```python
# app/services/audit_service.py
class AuditableService:
    """可审计的基础服务类 — 自动记录变更前后值"""

    async def audited_update(
        self, db: AsyncSession, model_instance, update_data: dict, user: User
    ):
        # 记录变更前的值
        old_value = {
            col.name: getattr(model_instance, col.name)
            for col in model_instance.__table__.columns
            if col.name in update_data
        }

        # 执行更新
        for key, value in update_data.items():
            setattr(model_instance, key, value)
        await db.flush()

        # 记录变更后的值
        new_value = {k: update_data[k] for k in old_value}

        # 写入审计日志(关联具体字段变更)
        await audit_repo.create(db, AuditLogCreate(
            user_id=user.id,
            user_role=user.role,
            action="UPDATE",
            resource=model_instance.__tablename__,
            resource_id=str(model_instance.id),
            old_value=old_value,
            new_value=new_value,
        ))
```

### 12.3 审计日志存储与检索

```
写入链路:
  AuditMiddleware → Celery Task → PostgreSQL (按月分区)
                                → Elasticsearch (全文索引)

查询链路:
  近期(<30天) → PostgreSQL 当月分区表(快速精确查询)
  历史(>30天) → Elasticsearch (全文搜索/聚合分析)

归档策略:
  - 热数据: 近 3 个月保留在 PostgreSQL
  - 温数据: 3-12 个月归档至 Elasticsearch
  - 冷数据: >12 个月压缩归档至 MinIO (对象存储)
  - 合规保留: 审计日志至少保留 3 年
```

### 12.4 合规报表

```python
# app/services/report_engine.py
class ComplianceReporter:
    async def generate_access_report(self, period: str) -> AccessReport:
        """生成数据访问审计报告: 谁在何时访问了什么数据"""
        ...

    async def generate_change_report(self, period: str) -> ChangeReport:
        """生成数据变更报告: 所有 CREATE/UPDATE/DELETE 操作汇总"""
        ...

    async def generate_login_report(self, period: str) -> LoginReport:
        """生成登录审计报告: 登录次数、异常登录、失败尝试"""
        ...

    async def generate_sensitive_access_report(self, period: str) -> SensitiveReport:
        """生成敏感数据访问报告: 身份证/手机号等字段的查看记录"""
        ...
```

---

## 13. 事务一致性保障

### 13.1 事务边界原则

```
┌────────────────────────────────────────────────┐
│              事务设计原则                        │
│                                                │
│  1. Service 层为事务边界，一个业务操作 = 一个事务  │
│  2. Repository 层不管理事务，只做数据访问         │
│  3. 跨 Service 调用通过 Saga 编排               │
│  4. 所有写操作必须携带 idempotency_key           │
│  5. 财务操作使用乐观锁(version)防并发            │
└────────────────────────────────────────────────┘
```

### 13.2 财务扣费事务 (核心示例)

```python
# app/services/account_service.py
from sqlalchemy import text

class AccountService:
    async def charge(
        self,
        db: AsyncSession,
        elder_id: UUID,
        amount: Decimal,
        category: str,
        reference_id: UUID,
        reference_type: str,
        description: str,
        idempotency_key: str,
        operator_id: UUID | None = None,
    ) -> Transaction:
        """
        扣费操作 — 保证事务一致性:
        1. 幂等检查(同一 key 不重复扣费)
        2. 乐观锁更新余额(防并发超扣)
        3. 原子写入: 余额更新 + 流水记录在同一事务
        4. 余额预警异步触发
        """
        async with db.begin():
            # 1. 幂等检查
            existing = await db.execute(
                select(Transaction).where(
                    Transaction.idempotency_key == idempotency_key
                )
            )
            if existing.scalar_one_or_none():
                return existing.scalar_one()  # 返回已有记录

            # 2. 加载账户(带行锁 FOR UPDATE)
            account = await db.execute(
                select(ElderAccount)
                .where(ElderAccount.elder_id == elder_id)
                .with_for_update()
            )
            account = account.scalar_one()

            # 3. 余额校验
            if account.balance < amount:
                raise BusinessError(
                    f"余额不足: 当前 {account.balance}, 需扣 {amount}"
                )

            # 4. 乐观锁更新余额
            balance_before = account.balance
            result = await db.execute(
                text("""
                    UPDATE elder_accounts
                    SET balance = balance - :amount,
                        version = version + 1,
                        updated_at = NOW()
                    WHERE id = :id AND version = :version
                """),
                {"amount": amount, "id": account.id, "version": account.version}
            )
            if result.rowcount == 0:
                raise ConcurrencyError("并发冲突，请重试")

            # 5. 写入交易流水
            txn = Transaction(
                account_id=account.id,
                elder_id=elder_id,
                type="charge",
                category=category,
                amount=-amount,
                balance_before=balance_before,
                balance_after=balance_before - amount,
                reference_id=reference_id,
                reference_type=reference_type,
                description=description,
                idempotency_key=idempotency_key,
                operator_id=operator_id,
            )
            db.add(txn)
            await db.flush()

            # 6. 余额预警(异步，不阻塞事务)
            new_balance = balance_before - amount
            if new_balance < account.alert_threshold:
                send_balance_alert.delay(
                    elder_id=str(elder_id),
                    balance=float(new_balance),
                    threshold=float(account.alert_threshold),
                )

            return txn
```

### 13.3 Saga 模式 — 入院办理编排

入院涉及多步骤，使用 Saga 编排 + 补偿确保一致性：

```python
# app/services/saga/admission_saga.py
from dataclasses import dataclass

@dataclass
class SagaStep:
    name: str
    execute: Callable
    compensate: Callable  # 补偿/回滚函数

class AdmissionSaga:
    """入院办理 Saga: 任一步骤失败则按逆序执行补偿"""

    def __init__(self, db: AsyncSession):
        self.db = db
        self.completed_steps: list[SagaStep] = []

    async def execute(self, elder_id: UUID, admission: AdmissionRequest):
        steps = [
            SagaStep(
                name="validate_elder",
                execute=lambda: self._validate_elder(elder_id),
                compensate=lambda ctx: None,  # 验证无需补偿
            ),
            SagaStep(
                name="assign_bed",
                execute=lambda: self._assign_bed(admission.bed_id, elder_id),
                compensate=lambda ctx: self._release_bed(ctx["bed_id"]),
            ),
            SagaStep(
                name="create_contract",
                execute=lambda: self._create_contract(elder_id, admission),
                compensate=lambda ctx: self._void_contract(ctx["contract_id"]),
            ),
            SagaStep(
                name="create_account",
                execute=lambda: self._create_account(elder_id, admission.deposit),
                compensate=lambda ctx: self._close_account(ctx["account_id"]),
            ),
            SagaStep(
                name="update_status",
                execute=lambda: self._update_elder_status(elder_id),
                compensate=lambda ctx: self._revert_elder_status(elder_id),
            ),
        ]

        context = {}
        try:
            for step in steps:
                result = await step.execute()
                context.update(result or {})
                self.completed_steps.append(step)
        except Exception as e:
            # 逆序执行补偿
            for step in reversed(self.completed_steps):
                try:
                    await step.compensate(context)
                except Exception as comp_err:
                    logger.error(f"Saga补偿失败 [{step.name}]: {comp_err}")
                    # 记录到死信队列，人工介入
                    await dead_letter_queue.push({
                        "saga": "admission",
                        "step": step.name,
                        "elder_id": str(elder_id),
                        "error": str(comp_err),
                    })
            raise SagaRollbackError(f"入院办理失败，已回滚: {e}") from e

        return context
```

### 13.4 分布式锁 — 防止并发操作

```python
# app/core/distributed_lock.py
import redis.asyncio as redis

class DistributedLock:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    async def acquire(self, key: str, ttl: int = 30) -> bool:
        """尝试获取分布式锁"""
        return await self.redis.set(
            f"lock:{key}", "1", nx=True, ex=ttl
        )

    async def release(self, key: str):
        await self.redis.delete(f"lock:{key}")

# 使用示例: 防止同一床位被并发分配
async def assign_bed(bed_id: UUID, elder_id: UUID):
    lock = DistributedLock(redis_client)
    lock_key = f"bed:{bed_id}"

    if not await lock.acquire(lock_key, ttl=10):
        raise ConcurrencyError("该床位正在被操作，请稍后重试")
    try:
        # 执行床位分配逻辑
        ...
    finally:
        await lock.release(lock_key)
```

---

## 14. 幂等补偿机制

### 14.1 幂等设计总览

```
┌──────────────────────────────────────────────────────────┐
│                    幂等三层防护                            │
│                                                          │
│  第1层: 客户端 — 生成 X-Idempotency-Key (UUID)           │
│  第2层: 中间件 — Redis 缓存检查 + 请求去重               │
│  第3层: 数据库 — idempotency_key UNIQUE 约束兜底          │
└──────────────────────────────────────────────────────────┘
```

### 14.2 幂等中间件

```python
# app/middleware/idempotency.py
import hashlib
import json

IDEMPOTENT_METHODS = {"POST", "PUT", "PATCH"}
IDEMPOTENT_TTL = 3600 * 24  # 24小时内同一 key 返回缓存

class IdempotencyMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        if request.method not in IDEMPOTENT_METHODS:
            return await call_next(request)

        idempotency_key = request.headers.get("X-Idempotency-Key")
        if not idempotency_key:
            # 写操作无幂等键则自动根据请求内容生成
            body = await request.body()
            idempotency_key = hashlib.sha256(
                f"{request.url.path}:{request.method}:{body}".encode()
            ).hexdigest()

        cache_key = f"idempotent:{idempotency_key}"

        # 1. 检查是否已有缓存响应
        cached = await redis.get(cache_key)
        if cached:
            data = json.loads(cached)
            return JSONResponse(
                status_code=data["status_code"],
                content=data["body"],
                headers={"X-Idempotent-Replay": "true"},
            )

        # 2. 设置处理中标记(防并发重复提交)
        lock_key = f"idempotent_lock:{idempotency_key}"
        acquired = await redis.set(lock_key, "processing", nx=True, ex=30)
        if not acquired:
            return JSONResponse(
                status_code=409,
                content={"code": 409, "message": "请求正在处理中，请勿重复提交"},
            )

        try:
            # 3. 执行实际请求
            response = await call_next(request)

            # 4. 缓存成功响应
            if 200 <= response.status_code < 300:
                body = b""
                async for chunk in response.body_iterator:
                    body += chunk
                await redis.setex(cache_key, IDEMPOTENT_TTL, json.dumps({
                    "status_code": response.status_code,
                    "body": json.loads(body),
                }))
                return Response(
                    content=body,
                    status_code=response.status_code,
                    headers=dict(response.headers),
                    media_type=response.media_type,
                )

            return response
        finally:
            await redis.delete(lock_key)
```

### 14.3 数据库层幂等兜底

```sql
-- transactions 表的 idempotency_key 唯一约束
-- 即使 Redis 缓存失效，数据库层依然防止重复写入
ALTER TABLE transactions
    ADD CONSTRAINT uq_transactions_idempotency UNIQUE (idempotency_key);

-- care_tasks 表的 idempotency_key 唯一约束
ALTER TABLE care_tasks
    ADD CONSTRAINT uq_care_tasks_idempotency UNIQUE (idempotency_key);
```

### 14.4 补偿事务 — 冲正机制

```python
# app/services/account_service.py
class AccountService:
    async def reverse_transaction(
        self,
        db: AsyncSession,
        original_txn_id: UUID,
        reason: str,
        operator_id: UUID,
    ) -> Transaction:
        """
        冲正/退款: 对已完成的扣费进行反向操作
        - 幂等: 同一原始交易只能冲正一次
        - 原子: 余额恢复 + 冲正流水在同一事务
        """
        async with db.begin():
            # 1. 加载原始交易
            original = await db.get(Transaction, original_txn_id)
            if not original:
                raise BusinessError("原始交易不存在")
            if original.status == "reversed":
                raise BusinessError("该交易已冲正，不可重复操作")

            # 2. 检查是否已有冲正记录(幂等)
            existing_reversal = await db.execute(
                select(Transaction).where(
                    Transaction.reversed_by == original_txn_id
                )
            )
            if existing_reversal.scalar_one_or_none():
                return existing_reversal.scalar_one()

            # 3. 恢复余额(乐观锁)
            account = await db.execute(
                select(ElderAccount)
                .where(ElderAccount.id == original.account_id)
                .with_for_update()
            )
            account = account.scalar_one()
            reverse_amount = abs(original.amount)

            result = await db.execute(
                text("""
                    UPDATE elder_accounts
                    SET balance = balance + :amount,
                        version = version + 1,
                        updated_at = NOW()
                    WHERE id = :id AND version = :version
                """),
                {"amount": reverse_amount, "id": account.id,
                 "version": account.version},
            )
            if result.rowcount == 0:
                raise ConcurrencyError("并发冲突，请重试")

            # 4. 写入冲正流水
            reversal_txn = Transaction(
                account_id=account.id,
                elder_id=original.elder_id,
                type="refund",
                category=original.category,
                amount=reverse_amount,
                balance_before=account.balance,
                balance_after=account.balance + reverse_amount,
                reference_id=original.reference_id,
                reference_type=original.reference_type,
                description=f"冲正: {reason}",
                idempotency_key=f"reverse-{original_txn_id}",
                operator_id=operator_id,
            )
            db.add(reversal_txn)

            # 5. 标记原始交易为已冲正
            original.status = "reversed"
            original.reversed_by = reversal_txn.id

            return reversal_txn
```

### 14.5 Celery 任务重试与补偿

```python
# app/tasks/billing.py
from celery import shared_task
from celery.exceptions import MaxRetriesExceededError

@shared_task(
    bind=True,
    max_retries=5,
    default_retry_delay=60,               # 首次重试间隔 60s
    retry_backoff=True,                    # 指数退避
    retry_backoff_max=3600,                # 最大退避 1 小时
    acks_late=True,                        # 完成后才确认
    reject_on_worker_lost=True,            # worker 崩溃自动重入队列
)
def process_monthly_billing(self, elder_id: str, month: str):
    """
    月度自动扣费任务:
    - 幂等: idempotency_key = f"monthly-{elder_id}-{month}"
    - 重试: 指数退避最多 5 次
    - 补偿: 超过最大重试写入死信队列
    """
    idempotency_key = f"monthly-{elder_id}-{month}"
    try:
        with get_db_session() as db:
            account_service.charge(
                db=db,
                elder_id=UUID(elder_id),
                amount=calculate_monthly_fee(elder_id, month),
                category="room_fee",
                reference_id=None,
                reference_type="monthly_billing",
                description=f"{month} 月度房费",
                idempotency_key=idempotency_key,
            )
    except InsufficientBalanceError:
        # 余额不足不重试，发送通知
        send_balance_alert.delay(elder_id=elder_id)
    except ConcurrencyError:
        # 并发冲突，重试
        self.retry(countdown=5)
    except Exception as exc:
        try:
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            # 超过最大重试，写入死信队列
            dead_letter_queue.push({
                "task": "monthly_billing",
                "elder_id": elder_id,
                "month": month,
                "error": str(exc),
                "needs_manual_intervention": True,
            })
            logger.critical(f"月度扣费失败(已达最大重试): {elder_id} {month}")
```

---

## 15. 可观测与运维体系

### 15.1 三大支柱

```
┌─────────────────────────────────────────────────────┐
│                   可观测性三支柱                      │
│                                                     │
│  Metrics (指标)     Logs (日志)     Traces (链路)    │
│  ┌──────────┐      ┌──────────┐   ┌──────────┐    │
│  │Prometheus│      │ Loki     │   │ Jaeger   │    │
│  │ +Grafana │      │ +Grafana │   │ (OTLP)   │    │
│  └──────────┘      └──────────┘   └──────────┘    │
│       │                 │              │            │
│       └────────────┬────┘──────────────┘            │
│                    ▼                                │
│              Grafana 统一仪表盘                      │
└─────────────────────────────────────────────────────┘
```

### 15.2 Metrics — Prometheus 指标

```python
# app/core/metrics.py
from prometheus_client import Counter, Histogram, Gauge, Info

# 请求指标
http_requests_total = Counter(
    "http_requests_total",
    "Total HTTP requests",
    ["method", "path", "status", "client_type"],
)
http_request_duration = Histogram(
    "http_request_duration_seconds",
    "HTTP request latency",
    ["method", "path"],
    buckets=[0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0],
)

# 业务指标
active_elders = Gauge(
    "active_elders_total",
    "Number of currently admitted elders",
)
care_tasks_completed = Counter(
    "care_tasks_completed_total",
    "Completed care tasks",
    ["category"],
)
account_balance_alerts = Counter(
    "account_balance_alerts_total",
    "Balance alert triggers",
)
bed_occupancy = Gauge(
    "bed_occupancy_ratio",
    "Bed occupancy ratio by building",
    ["building"],
)
transaction_amount = Histogram(
    "transaction_amount_yuan",
    "Transaction amounts",
    ["type", "category"],
    buckets=[10, 50, 100, 500, 1000, 5000, 10000],
)

# Celery 任务指标
celery_task_duration = Histogram(
    "celery_task_duration_seconds",
    "Celery task execution time",
    ["task_name", "status"],
)
celery_task_retries = Counter(
    "celery_task_retries_total",
    "Celery task retry count",
    ["task_name"],
)
```

```python
# app/middleware/metrics.py
class MetricsMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        client_type = request.headers.get("X-Client-Type", "unknown")
        with http_request_duration.labels(
            method=request.method, path=self._normalize_path(request.url.path)
        ).time():
            response = await call_next(request)

        http_requests_total.labels(
            method=request.method,
            path=self._normalize_path(request.url.path),
            status=response.status_code,
            client_type=client_type,
        ).inc()

        return response
```

### 15.3 Logs — 结构化日志

```python
# app/core/logging.py
import structlog
import logging

def setup_logging():
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.JSONRenderer(),   # JSON 输出 → Loki
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
    )

logger = structlog.get_logger()

# 使用示例:
# logger.info("扣费完成",
#     elder_id=str(elder_id),
#     amount=float(amount),
#     balance_after=float(new_balance),
#     trace_id=trace_id,
# )
```

### 15.4 Traces — 链路追踪

```python
# app/middleware/trace.py
import uuid
from opentelemetry import trace
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

def setup_tracing():
    provider = TracerProvider()
    exporter = JaegerExporter(agent_host_name="jaeger", agent_port=6831)
    provider.add_span_processor(BatchSpanProcessor(exporter))
    trace.set_tracer_provider(provider)

tracer = trace.get_tracer("elderly-care-platform")

class TraceMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        trace_id = request.headers.get("X-Request-Id", str(uuid.uuid4()))
        request.state.trace_id = trace_id

        with tracer.start_as_current_span(
            f"{request.method} {request.url.path}",
            attributes={
                "http.method": request.method,
                "http.url": str(request.url),
                "http.client_type": request.headers.get("X-Client-Type", ""),
                "trace.id": trace_id,
            },
        ):
            response = await call_next(request)
            response.headers["X-Trace-Id"] = trace_id
            return response
```

### 15.5 告警规则 (Prometheus Alertmanager)

```yaml
# prometheus/alert_rules.yml
groups:
  - name: platform_alerts
    rules:
      # API 高错误率
      - alert: HighErrorRate
        expr: |
          sum(rate(http_requests_total{status=~"5.."}[5m]))
          / sum(rate(http_requests_total[5m])) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "API 错误率超过 5%"

      # API 响应延迟
      - alert: HighLatency
        expr: |
          histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "P95 响应延迟超过 2 秒"

      # 数据库连接池耗尽
      - alert: DBConnectionPoolExhausted
        expr: pg_stat_activity_count > 80
        for: 2m
        labels:
          severity: critical

      # Celery 任务堆积
      - alert: CeleryQueueBacklog
        expr: celery_queue_length > 1000
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Celery 任务队列积压超过 1000"

      # 余额预警频率异常(可能系统扣费bug)
      - alert: AbnormalBalanceAlerts
        expr: rate(account_balance_alerts_total[1h]) > 10
        for: 30m
        labels:
          severity: warning
        annotations:
          summary: "余额预警触发频率异常偏高"

      # 床位入住率预警
      - alert: LowOccupancy
        expr: bed_occupancy_ratio < 0.6
        for: 24h
        labels:
          severity: info
        annotations:
          summary: "床位入住率低于 60%"
```

### 15.6 Grafana 仪表盘规划

| 仪表盘 | 关键面板 |
|--------|---------|
| **API 概览** | QPS、错误率、P50/P95/P99 延迟、管理端/小程序请求分布 |
| **业务指标** | 在住人数、入住率、当月营收、护理任务完成率 |
| **财务监控** | 充值/扣费趋势、余额分布、预警触发次数 |
| **护理质量** | 任务完成率、平均服务时长、满意度评分 |
| **基础设施** | CPU/Memory、DB 连接数、Redis 命中率、Celery 队列深度 |

### 15.7 健康检查

```python
# app/api/v1/health.py
from fastapi import APIRouter

router = APIRouter(tags=["Health"])

@router.get("/health")
async def health_check():
    """K8s / 负载均衡器健康探针"""
    return {"status": "ok"}

@router.get("/health/ready")
async def readiness_check(db: AsyncSession = Depends(get_db)):
    """就绪探针: 检查所有依赖"""
    checks = {}
    # PostgreSQL
    try:
        await db.execute(text("SELECT 1"))
        checks["postgres"] = "ok"
    except Exception as e:
        checks["postgres"] = f"error: {e}"

    # Redis
    try:
        await redis.ping()
        checks["redis"] = "ok"
    except Exception as e:
        checks["redis"] = f"error: {e}"

    # MinIO
    try:
        minio_client.bucket_exists("health-check")
        checks["minio"] = "ok"
    except Exception as e:
        checks["minio"] = f"error: {e}"

    all_ok = all(v == "ok" for v in checks.values())
    return JSONResponse(
        status_code=200 if all_ok else 503,
        content={"status": "ready" if all_ok else "degraded", "checks": checks},
    )
```

---

## 16. 部署与安全

### 16.1 Docker Compose 部署架构

```yaml
# docker-compose.yml
services:
  # ===== 应用层 =====
  web-admin:
    build: ./web-admin
    ports: ["3000:3000"]
    environment:
      - NEXT_PUBLIC_API_URL=http://backend:8000
      - NEXT_PUBLIC_WS_URL=ws://backend:8000
    depends_on: [backend]
    # 注: 家属端微信小程序为独立项目(mini-program/)
    # 通过微信开发者工具上传，不需要容器部署
    # 小程序直接调用后端 /api/v1/family/* 接口

  backend:
    build: ./backend
    ports: ["8000:8000"]
    environment:
      - DATABASE_URL=postgresql+asyncpg://user:pass@postgres:5432/elderly_care
      - REDIS_URL=redis://redis:6379/0
      - MINIO_ENDPOINT=minio:9000
      - FIELD_ENCRYPTION_KEY=${FIELD_ENCRYPTION_KEY}
      - JWT_SECRET=${JWT_SECRET}
    depends_on: [postgres, redis, minio]

  celery-worker:
    build: ./backend
    command: celery -A celery_worker worker -l info -c 4
    environment:
      - DATABASE_URL=postgresql+asyncpg://user:pass@postgres:5432/elderly_care
      - REDIS_URL=redis://redis:6379/0
    depends_on: [postgres, redis]

  celery-beat:
    build: ./backend
    command: celery -A celery_worker beat -l info
    depends_on: [redis]

  # ===== 数据层 =====
  postgres:
    image: postgres:16-alpine
    volumes: ["pgdata:/var/lib/postgresql/data"]
    environment:
      POSTGRES_DB: elderly_care
      POSTGRES_USER: user
      POSTGRES_PASSWORD: ${DB_PASSWORD}

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD} --maxmemory 256mb

  minio:
    image: minio/minio
    command: server /data --console-address ":9001"
    volumes: ["minio_data:/data"]

  # ===== 可观测层 =====
  prometheus:
    image: prom/prometheus
    volumes: ["./prometheus:/etc/prometheus"]
    ports: ["9090:9090"]

  grafana:
    image: grafana/grafana
    ports: ["3001:3000"]
    volumes: ["grafana_data:/var/lib/grafana"]

  loki:
    image: grafana/loki
    ports: ["3100:3100"]

  jaeger:
    image: jaegertracing/all-in-one
    ports: ["16686:16686", "6831:6831/udp"]

  # ===== 网关 =====
  nginx:
    image: nginx:alpine
    ports: ["80:80", "443:443"]
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on: [web-admin, backend]
    # Nginx 路由:
    #   /            → web-admin (Next.js 管理端)
    #   /api/v1/*    → backend  (FastAPI, 管理端+小程序共用)
    #   /ws          → backend  (WebSocket, 管理端专用)

volumes:
  pgdata:
  minio_data:
  grafana_data:
```

### 16.2 安全设计

| 层面 | 措施 |
|------|------|
| **传输安全** | 全站 HTTPS (TLS 1.3)，内网通信可选 mTLS |
| **认证(管理端)** | JWT (access 15min + refresh 7d)，密码 bcrypt + salt |
| **认证(小程序)** | 微信 code → openid → JWT，手机号绑定验证 |
| **授权** | 四层权限模型 (客户端隔离/RBAC/行级/字段级) |
| **数据加密** | PII 字段 AES 加密存储，备份加密 |
| **输入校验** | Pydantic Schema 全字段校验，防 SQL 注入/XSS |
| **限流** | Nginx 全局限流 + 接口级令牌桶限流 |
| **CORS** | 管理端白名单域名；小程序通过 wx.request 不受 CORS 限制 |
| **微信支付安全** | 回调签名验证、HTTPS 回调 URL、商户密钥加密 |
| **日志脱敏** | 审计日志自动过滤密码/身份证/token/openid |
| **依赖安全** | `pip-audit` + `npm audit` 定期扫描 |
| **密钥管理** | 所有密钥(JWT_SECRET/WX_APP_SECRET/支付密钥)通过环境变量注入 |

### 16.3 备份策略

```
PostgreSQL:
  - 每日全量备份 (pg_dump) → MinIO 加密存储
  - WAL 持续归档 → 支持时间点恢复 (PITR)
  - 保留周期: 日备份 30 天，月备份 12 个月

MinIO 文件:
  - 跨区域复制 (如有多机房)
  - 版本控制开启

Redis:
  - RDB 快照 + AOF 持久化
  - 主从复制
```

### 16.4 数据库迁移流程

```bash
# 创建迁移
alembic revision --autogenerate -m "add_survey_tables"

# 检查迁移 SQL (先审查再执行)
alembic upgrade head --sql

# 执行迁移
alembic upgrade head

# 回滚 (紧急情况)
alembic downgrade -1
```

---

## 附录: 关键设计决策记录

| 决策项 | 选择 | 理由 |
|--------|------|------|
| 管理端 Web | Next.js 15 (App Router) | SSR 提升首屏速度，Server Components 减少客户端 bundle |
| 家属端 | 微信原生小程序 (Skyline) | 用户量 ~500 家属，微信生态免安装，支持订阅消息+微信支付 |
| 后端框架 | FastAPI | 异步原生、类型提示、自动文档、性能优于 Django/Flask |
| ORM | SQLAlchemy 2.x (async) | Python 生态最成熟，支持异步，复杂查询能力强 |
| 管理端状态 | Zustand | 轻量(~1KB)、无 Provider、TypeScript 友好 |
| 小程序状态 | mobx-miniprogram | 小程序生态主流方案，响应式数据绑定 |
| 小程序 UI | Vant Weapp | MIT 许可，组件丰富，主题定制，社区活跃 |
| 任务队列 | Celery + Redis | 成熟稳定，支持定时任务/重试/死信队列 |
| 对象存储 | MinIO | S3 兼容，自托管免费，后续可迁移至云 S3 |
| 监控 | Prometheus + Grafana | 云原生标准方案，社区生态丰富 |
| 数据库 | PostgreSQL 16 | JSONB 支持灵活 Schema、分区表、行锁、成熟可靠 |
| 支付 | 微信支付 (JSAPI) | 小程序内原生支持，家属充值场景 |
